#import "lib/ilm.typ": *

#set text(lang: "ru")
#set math.equation(numbering: "1")

#show ref: it => {
  lower(it)
}


#show: ilm.with(
  title: [Применение методов вычислительной математики в задачах управления],
  author: 
    "Панков Василий <pank-su>",
  author-format: (author) => [
    #stack(dir: ltr)[#block(
        image("images/000_avatar.png", width: 3em, height: 3em),
        radius: 50%,
        clip: true,
      )][#h(1em)][#text(author, size: 1.6em)]
  ],
  date: datetime.today(),
  abstract: [Доклад],
  table-of-contents: none,
  external-link-circle: false
)


= Введение

Доброе утро, я Панков Василий, и сегодня я расскажу вам о применении методов вычислительной математики в задачах управления. Мы рассмотрим, как математические модели и алгоритмы могут помочь нам в оптимизации управления системами.

Начнем с "базы":


*Вычислительная математика* фактически дает нам возможность рассчитать что либо альтернативным способом, с опр. точностью. В основном оптимизируя/структурируя вычисления для компьютера.

== Система управления

Вспомним лекции:

/ Управление: это целенаправленное воздействие на объект или процесс для поддержания его состояния или внесения заданных изменений.

/ Система управления: комплекс взаимосвязанных компонентов, обладающий свойством целостности: при вступлении элементов в связи возникают новые свойства, не характерные по отдельности.

#figure(image("images/001_система_управления.png"))

Для выбора вычислительного метода критически важна классификация задач управления по степени их формализации:
- *Хорошо структурированные*: полностью формализуемые задачи.
- *Слабо структурированные*: задачи с неопределенностью, где вычислительные методы сочетаются с экспертными оценками.
- *Неструктурированные*: задачи, решаемые преимущественно эвристическими методами.

= Математическое описание и переходная матрица

Перейдем на более высокий уровень абстракции и рассмотрим взаимодействие нескольких систем управления.
В рамках системного подхода мы рассматриваем иерархию "элемент — устройство — система"

От одномерной системы перейдем к многомерной

#figure(image("images/002_многомерной_систем.png"),)

Данную систему называют *многомерной линейной нестационарной системой* (МЛНС).

*Многомерные линейные нестационарные системы* в отличие от одномерных имеют $r$ входов и $k$ выходов.

Тогда сигналы описываем в виде векторов:

$
  g(t) = vec(g_1(t), dot, dot, g_n(r)), space y(t) = vec(y_1(t), dot, dot, y_k(t))
$

Описывается система с помощью уравнения состояния:

$
  limits(x)^dot = A(t) x (t) + B(t) g(t)
$


с начальным условиями:

$
  x(t_0) = x_0
$

и уравнениями выхода:

$
  y(t) = C(t) x(t)
$

где:
- $x(t)$ - n-мерный вектор состояния системы
- $g(t)$ - r-мерный вектор входных взаимодействий (управлений)
- $y(t)$ - k-мерный вектор выходов системы
- $x_0$ - начальное состояние системы
- $t$ - время

- $A(t)$, $B(t)$, $C(t)$ - матрицы размеров соответственно $n times n$, $n times r$, $k times n$ 


Если $r = 1$ и $k = 1$, то система называется *одномерной*.

Если $A$, $B$, $C$ не зависят от времени $t$, то система называется *стационарной*.

== Пример

Записать уравнения состояния и выхода системы:
$
  cases(
    dot(x)_1 = x_2 + g_1,
    dot(x)_2 = -x_1 + 2x_2 - 3g_1
  ), quad y_1 = x_2
$
в матричной форме.

Определяем размерности сигналов: $n = 2, r = 1, k = 1$ и записываем соответствующие уравнения:

$
  dif/(dif t) vec(x_1, x_2) = 
  underbrace(mat(0, 1; -1, 2), A(t)) 
  vec(x_1, x_2) 
  + 
  underbrace(vec(1, -3), B(t)) 
  g_1, 
  quad 
  y_1 = 
  underbrace(mat(0, 1), C(t)) 
  vec(x_1, x_2)
$

== Переходная матрица (матрица Коши)

Для анализа выходных процессов системы, нужно найти закон изменения вектора состояния. Реакция системы (выходной сигнал) состоит из двух частей:

- *Свободное движение* - реакция системы при нулевом входе ($g(t) = 0$)
- *Вынужденное движение* - реакция системы на внешнее воздействие при нулевых начальных условиях ($x_0 = 0$)

Закон измененения вектора состояния задается формулой:

$
  x(t) = Phi(t, t_0) x_0 + integral_{t_0}^t Phi(t, tau) B(tau) g(tau) dif tau
$

В этом выражении $Phi(t, tau)$ - *переходная матрица* (или *матрица Коши*), являющаяся решением уравнения:

$
  (partial Phi(t, tau))/(partial t) = A(t) Phi(t, tau) quad Phi(tau, tau) = E
$

$E$ - единичная матрица.

Для стационарных систем (где $A$, $B$, $C$ не зависят от времени) переходная матрица может быть выражена через экспоненту матрицы:

$
  Phi(t, tau) = e^(A (t - tau)) = Phi(η)
$

=== Свойства переходной матрицы

- $Phi(t, tau) = Phi(t, t_0) Phi(t_0, tau)$
- $Phi(t, tau)^{-1} = Phi(tau, t)$
- *Формула Лиувилля-Остроградского*: $det(Phi(t, t_0)) = exp(integral_{t_0}^t tr(A(tau)) dif tau)$. Она позволяет отслеживать накопление численной ошибки при интегрировании.

=== Вычислительная математика и переходная матрица

Так причем тут вычислительная математика? 

Так как для нестационарных систем $A(t)$ зависит от времени, то аналитическое решение уравнения для $Phi(t, tau)$ может быть сложным или невозможным. Поэтому мы прибегаем к численным методам для приближенного вычисления переходной матрицы.

==== Ряд Тейлора

Переходную матрицу (экспоненту матрицы) можно разложить в ряд Тейлора:

$
  e^(A tau) = sum_(n=0)^infinity (A^n tau^n) / n!
$

Проблемы:
- Сходимость ряда может быть медленной, особенно для больших значений $tau$.
- Сложность: каждый член требует перемножения матриц, что имеет сложность $O(n^3)$ для матриц размера $n times n$.





==== Использование теоремы Кели-Гамильтона (метод Сильвестра) 

Согласно теореме Кэли-Гамильтона, любая квадратная матрица $A$ порядка $n$ удовлетворяет своему характеристическому уравнению. Это означает, что любую степень матрицы $A^k$ (где $k >= n$) можно выразить через линейную комбинацию её младших степеней ($E, A, A^2, dots, A^{n-1}$).

Алгоритм реализации:

+ Находим собственные числа $lambda_i$ матрицы $A$ (решая характеристическое уравнение $det(A - lambda E) = 0$).
+ Записываем экспоненту как полином:
  $e^(A tau) = alpha_0(tau) E + alpha_1(tau) A + dots + alpha_(n-1)(tau) A^(n-1)$
+ Составляем систему из $n$ уравнений для нахождения неизвестных коэффициентов $alpha_i(tau)$, используя условия $e^(lambda_i tau) = alpha_0(tau) + alpha_1(tau) lambda_i + dots + alpha_(n-1)(tau) lambda_i^(n-1)$ для каждого собственного числа $lambda_i$.


Преимущества:
- Быстрое вычисление экспоненты матрицы, особенно для больших $tau$
- Сложность: нахождение собственных чисел и решение системы линейных уравнений имеет сложность $O(n^3)$, что может быть эффективнее, чем прямое перемножение матриц для больших степеней.

Есть и другие методы, но если я буду перечислять все, то доклад будет бесконечным, так что остановимся на этих двух.

= Дискретизация и численное интегрирование

Сейчас мы рассмотрели системы в непрерывном времени, но 
если мы захотим смоделировать систему на компьютере, то нам необходимо перейти к дискретному времени. 

Обозначим фиксированный шаг дискретизации как $T$.

Вернемся к уравнению состояния:

$
  limits(x)^dot = A(t) x (t) + B(t) g(t)
$

Преобразуем его в дискретную форму:

$
  x_(k + 1) = A_d x_k + B_d g_k
$

Вычисление этих матриц представляет собой нетривиальную алгоритмическую задачу.
Дискретная матрица $A_d$ строго равна матричной экспоненте за один шаг дискретизации:

$
  A_d = e^(A T)
$

Тогда дискретная матрица $B_d$ может быть вычислена через интеграл:
$
  B_d = integral_0^T e^(A tau) B dif tau
$

В данном случае мы можем использовать численные методы интегрирования.

== Метод Эйлера

Метод Эйлера - это простой численный метод для решения обыкновенных дифференциальных уравнений. Он использует линейную аппроксимацию для оценки следующего значения функции на основе её текущего значения и производной.

$
  x_(k + 1) = x_k + T (A x_k + B g_k)
$

Преимущества:
- Простота реализации
- Низкая вычислительная стоимость

Недостатки:
- Низкая точность (первый порядок)
- Может быть неустойчивым


== Метод Рунге-Кутта 4-го порядка

Метод Рунге-Кутта 4-го порядка (RK4) - это более сложный численный метод, который обеспечивает более высокую точность по сравнению с методом Эйлера. Он использует четыре оценки производной для вычисления следующего значения функции.

Вычисляем касательные в 4 разных точках:

$T$ - шаг дискретизации, $t_k$ - текущее время, $x_k$ - текущее значение вектора состояния.

+ $k_1 = f(t_k, x_k)$
+ $k_2 = f(t_k + T/2, x_k + (T/2) k_1)$
+ $k_3 = f(t_k + T/2, x_k + (T/2) k_2)$
+ $k_4 = f(t_k + T, x_k + T k_3)$

Итоговое значение вектора состояния на следующем такте собирается как взвешенная сумма этих коэффициентов:
$
  x_(k + 1) = x_k + (T/6) (k_1 + 2 k_2 + 2 k_3 + k_4)
$

Вычислительная суть этого метода в том, что он алгебраически эквивалентен удержанию членов ряда Тейлора вплоть до четвертой степени, 
но при этом машине не нужно вычислять сложные аналитические производные высоких порядков. Метод RK4 требует четырех обращений к правой части функции за один такт,
 что делает его вычислительно затратным, но взамен обеспечивает колоссальную точность с глобальной погрешностью $O(T^4)$, 
 предотвращая расходимость системы управления в реальном времени.

= Заключение